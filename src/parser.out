Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> decSeq
Rule 2     dec -> varDec
Rule 3     dec -> ID LPAREN paramList RPAREN LKEY block RKEY
Rule 4     dec -> type ID LPAREN paramList RPAREN LKEY block RKEY
Rule 5     decSeq -> dec
Rule 6     decSeq -> dec decSeq
Rule 7     varDec -> type varSpecSeq SEMICOLON
Rule 8     varSpecSeq -> varSpec
Rule 9     varSpecSeq -> varSpec COMMA varSpecSeq
Rule 10    varSpec -> ID
Rule 11    varSpec -> ID ASSIGN literal
Rule 12    varSpec -> ID LCOR NUMBER RCOR
Rule 13    varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY
Rule 14    type -> INT
Rule 15    type -> STRING
Rule 16    type -> BOOLEAN
Rule 17    block -> varDecList stmtList
Rule 18    stmt -> ifStmt
Rule 19    stmt -> whileStmt
Rule 20    stmt -> forStmt
Rule 21    stmt -> breakStmt
Rule 22    stmt -> returnStmt
Rule 23    stmt -> readStmt
Rule 24    stmt -> writeStmt
Rule 25    stmt -> assign SEMICOLON
Rule 26    stmt -> subCall SEMICOLON
Rule 27    stmt -> error
Rule 28    ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY
Rule 29    ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
Rule 30    whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY
Rule 31    forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
Rule 32    breakStmt -> BREAK SEMICOLON
Rule 33    readStmt -> READ var SEMICOLON
Rule 34    writeStmt -> WRITE expList SEMICOLON
Rule 35    returnStmt -> RETURN SEMICOLON
Rule 36    returnStmt -> RETURN exp SEMICOLON
Rule 37    subCall -> ID LPAREN expList RPAREN
Rule 38    assign -> var ASSIGN exp
Rule 39    assign -> var PLUSASSIGN exp
Rule 40    assign -> var MINUSASSIGN exp
Rule 41    assign -> var MULTASSIGN exp
Rule 42    assign -> var DIVIDEASSIGN exp
Rule 43    assign -> var MODASSIGN exp
Rule 44    exp -> exp PLUS exp
Rule 45    exp -> exp MINUS exp
Rule 46    exp -> exp MULT exp
Rule 47    exp -> exp DIVIDE exp
Rule 48    exp -> exp MOD exp
Rule 49    exp -> exp EQUALS exp
Rule 50    exp -> exp DIFFERENT exp
Rule 51    exp -> exp GT exp
Rule 52    exp -> exp GTE exp
Rule 53    exp -> exp LT exp
Rule 54    exp -> exp LTE exp
Rule 55    exp -> exp AND exp
Rule 56    exp -> exp OR exp
Rule 57    exp -> NOT exp
Rule 58    exp -> UMINUS exp
Rule 59    exp -> exp QMARK exp COLON exp
Rule 60    exp -> subCall
Rule 61    exp -> var
Rule 62    exp -> literal
Rule 63    exp -> LPAREN exp RPAREN
Rule 64    var -> ID
Rule 65    var -> ID LCOR exp RCOR
Rule 66    literal -> NUMBER
Rule 67    literal -> STRING_LITERAL
Rule 68    literal -> FALSE
Rule 69    literal -> TRUE
Rule 70    paramList -> paramSeq
Rule 71    paramList -> empty
Rule 72    paramSeq -> param
Rule 73    paramSeq -> param COMMA paramSeq
Rule 74    param -> type ID
Rule 75    param -> type ID LCOR RCOR
Rule 76    varDecList -> varDec varDecList
Rule 77    varDecList -> empty
Rule 78    stmtList -> stmt stmtList
Rule 79    stmtList -> empty
Rule 80    literalSeq -> literal
Rule 81    literalSeq -> literal COMMA literalSeq
Rule 82    expList -> expSeq
Rule 83    expList -> empty
Rule 84    expSeq -> exp
Rule 85    expSeq -> exp COMMA expSeq
Rule 86    empty -> <empty>

Terminals, with rules where they appear

AND                  : 55
ASSIGN               : 11 13 38
BOOLEAN              : 16
BREAK                : 32
COLON                : 59
COMMA                : 9 73 81 85
DIFFERENT            : 50
DIVIDE               : 47
DIVIDEASSIGN         : 42
ELSE                 : 29
EQUALS               : 49
FALSE                : 68
FOR                  : 31
GT                   : 51
GTE                  : 52
ID                   : 3 4 10 11 12 13 37 64 65 74 75
IF                   : 28 29
INT                  : 14
LCOR                 : 12 13 65 75
LKEY                 : 3 4 13 28 29 29 30 31
LPAREN               : 3 4 28 29 30 31 37 63
LT                   : 53
LTE                  : 54
MINUS                : 45
MINUSASSIGN          : 40
MOD                  : 48
MODASSIGN            : 43
MULT                 : 46
MULTASSIGN           : 41
NOT                  : 57
NUMBER               : 12 13 66
OR                   : 56
PLUS                 : 44
PLUSASSIGN           : 39
QMARK                : 59
RCOR                 : 12 13 65 75
READ                 : 33
RETURN               : 35 36
RKEY                 : 3 4 13 28 29 29 30 31
RPAREN               : 3 4 28 29 30 31 37 63
SEMICOLON            : 7 25 26 31 31 32 33 34 35 36
STRING               : 15
STRING_LITERAL       : 67
TRUE                 : 69
UMINUS               : 58
WHILE                : 30
WRITE                : 34
error                : 27

Nonterminals, with rules where they appear

assign               : 25 31 31
block                : 3 4 28 29 29 30 31
breakStmt            : 21
dec                  : 5 6
decSeq               : 1 6
empty                : 71 77 79 83
exp                  : 28 29 30 31 36 38 39 40 41 42 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 58 59 59 59 63 65 84 85
expList              : 34 37
expSeq               : 82 85
forStmt              : 20
ifStmt               : 18
literal              : 11 62 80 81
literalSeq           : 13 81
param                : 72 73
paramList            : 3 4
paramSeq             : 70 73
program              : 0
readStmt             : 23
returnStmt           : 22
stmt                 : 78
stmtList             : 17 78
subCall              : 26 60
type                 : 4 7 74 75
var                  : 33 38 39 40 41 42 43 61
varDec               : 2 76
varDecList           : 17 76
varSpec              : 8 9
varSpecSeq           : 7 9
whileStmt            : 19
writeStmt            : 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . decSeq
    (5) decSeq -> . dec
    (6) decSeq -> . dec decSeq
    (2) dec -> . varDec
    (3) dec -> . ID LPAREN paramList RPAREN LKEY block RKEY
    (4) dec -> . type ID LPAREN paramList RPAREN LKEY block RKEY
    (7) varDec -> . type varSpecSeq SEMICOLON
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    ID              shift and go to state 5
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    program                        shift and go to state 1
    decSeq                         shift and go to state 2
    dec                            shift and go to state 3
    varDec                         shift and go to state 4
    type                           shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> decSeq .

    $end            reduce using rule 1 (program -> decSeq .)


state 3

    (5) decSeq -> dec .
    (6) decSeq -> dec . decSeq
    (5) decSeq -> . dec
    (6) decSeq -> . dec decSeq
    (2) dec -> . varDec
    (3) dec -> . ID LPAREN paramList RPAREN LKEY block RKEY
    (4) dec -> . type ID LPAREN paramList RPAREN LKEY block RKEY
    (7) varDec -> . type varSpecSeq SEMICOLON
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    $end            reduce using rule 5 (decSeq -> dec .)
    ID              shift and go to state 5
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    dec                            shift and go to state 3
    decSeq                         shift and go to state 10
    varDec                         shift and go to state 4
    type                           shift and go to state 6

state 4

    (2) dec -> varDec .

    ID              reduce using rule 2 (dec -> varDec .)
    INT             reduce using rule 2 (dec -> varDec .)
    STRING          reduce using rule 2 (dec -> varDec .)
    BOOLEAN         reduce using rule 2 (dec -> varDec .)
    $end            reduce using rule 2 (dec -> varDec .)


state 5

    (3) dec -> ID . LPAREN paramList RPAREN LKEY block RKEY

    LPAREN          shift and go to state 11


state 6

    (4) dec -> type . ID LPAREN paramList RPAREN LKEY block RKEY
    (7) varDec -> type . varSpecSeq SEMICOLON
    (8) varSpecSeq -> . varSpec
    (9) varSpecSeq -> . varSpec COMMA varSpecSeq
    (10) varSpec -> . ID
    (11) varSpec -> . ID ASSIGN literal
    (12) varSpec -> . ID LCOR NUMBER RCOR
    (13) varSpec -> . ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    ID              shift and go to state 12

    varSpecSeq                     shift and go to state 13
    varSpec                        shift and go to state 14

state 7

    (14) type -> INT .

    ID              reduce using rule 14 (type -> INT .)


state 8

    (15) type -> STRING .

    ID              reduce using rule 15 (type -> STRING .)


state 9

    (16) type -> BOOLEAN .

    ID              reduce using rule 16 (type -> BOOLEAN .)


state 10

    (6) decSeq -> dec decSeq .

    $end            reduce using rule 6 (decSeq -> dec decSeq .)


state 11

    (3) dec -> ID LPAREN . paramList RPAREN LKEY block RKEY
    (70) paramList -> . paramSeq
    (71) paramList -> . empty
    (72) paramSeq -> . param
    (73) paramSeq -> . param COMMA paramSeq
    (86) empty -> .
    (74) param -> . type ID
    (75) param -> . type ID LCOR RCOR
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    RPAREN          reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    paramList                      shift and go to state 15
    paramSeq                       shift and go to state 16
    empty                          shift and go to state 17
    param                          shift and go to state 18
    type                           shift and go to state 19

state 12

    (4) dec -> type ID . LPAREN paramList RPAREN LKEY block RKEY
    (10) varSpec -> ID .
    (11) varSpec -> ID . ASSIGN literal
    (12) varSpec -> ID . LCOR NUMBER RCOR
    (13) varSpec -> ID . LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    LPAREN          shift and go to state 20
    COMMA           reduce using rule 10 (varSpec -> ID .)
    SEMICOLON       reduce using rule 10 (varSpec -> ID .)
    ASSIGN          shift and go to state 21
    LCOR            shift and go to state 22


state 13

    (7) varDec -> type varSpecSeq . SEMICOLON

    SEMICOLON       shift and go to state 23


state 14

    (8) varSpecSeq -> varSpec .
    (9) varSpecSeq -> varSpec . COMMA varSpecSeq

    SEMICOLON       reduce using rule 8 (varSpecSeq -> varSpec .)
    COMMA           shift and go to state 24


state 15

    (3) dec -> ID LPAREN paramList . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 25


state 16

    (70) paramList -> paramSeq .

    RPAREN          reduce using rule 70 (paramList -> paramSeq .)


state 17

    (71) paramList -> empty .

    RPAREN          reduce using rule 71 (paramList -> empty .)


state 18

    (72) paramSeq -> param .
    (73) paramSeq -> param . COMMA paramSeq

    RPAREN          reduce using rule 72 (paramSeq -> param .)
    COMMA           shift and go to state 26


state 19

    (74) param -> type . ID
    (75) param -> type . ID LCOR RCOR

    ID              shift and go to state 27


state 20

    (4) dec -> type ID LPAREN . paramList RPAREN LKEY block RKEY
    (70) paramList -> . paramSeq
    (71) paramList -> . empty
    (72) paramSeq -> . param
    (73) paramSeq -> . param COMMA paramSeq
    (86) empty -> .
    (74) param -> . type ID
    (75) param -> . type ID LCOR RCOR
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    RPAREN          reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    type                           shift and go to state 19
    paramList                      shift and go to state 28
    paramSeq                       shift and go to state 16
    empty                          shift and go to state 17
    param                          shift and go to state 18

state 21

    (11) varSpec -> ID ASSIGN . literal
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    literal                        shift and go to state 29

state 22

    (12) varSpec -> ID LCOR . NUMBER RCOR
    (13) varSpec -> ID LCOR . NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    NUMBER          shift and go to state 34


state 23

    (7) varDec -> type varSpecSeq SEMICOLON .

    ID              reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    INT             reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    STRING          reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    BOOLEAN         reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    $end            reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    error           reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    IF              reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    WHILE           reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    FOR             reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    BREAK           reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    RETURN          reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    READ            reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    WRITE           reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)
    RKEY            reduce using rule 7 (varDec -> type varSpecSeq SEMICOLON .)


state 24

    (9) varSpecSeq -> varSpec COMMA . varSpecSeq
    (8) varSpecSeq -> . varSpec
    (9) varSpecSeq -> . varSpec COMMA varSpecSeq
    (10) varSpec -> . ID
    (11) varSpec -> . ID ASSIGN literal
    (12) varSpec -> . ID LCOR NUMBER RCOR
    (13) varSpec -> . ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    ID              shift and go to state 36

    varSpec                        shift and go to state 14
    varSpecSeq                     shift and go to state 35

state 25

    (3) dec -> ID LPAREN paramList RPAREN . LKEY block RKEY

    LKEY            shift and go to state 37


state 26

    (73) paramSeq -> param COMMA . paramSeq
    (72) paramSeq -> . param
    (73) paramSeq -> . param COMMA paramSeq
    (74) param -> . type ID
    (75) param -> . type ID LCOR RCOR
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    param                          shift and go to state 18
    paramSeq                       shift and go to state 38
    type                           shift and go to state 19

state 27

    (74) param -> type ID .
    (75) param -> type ID . LCOR RCOR

    COMMA           reduce using rule 74 (param -> type ID .)
    RPAREN          reduce using rule 74 (param -> type ID .)
    LCOR            shift and go to state 39


state 28

    (4) dec -> type ID LPAREN paramList . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 40


state 29

    (11) varSpec -> ID ASSIGN literal .

    COMMA           reduce using rule 11 (varSpec -> ID ASSIGN literal .)
    SEMICOLON       reduce using rule 11 (varSpec -> ID ASSIGN literal .)


state 30

    (66) literal -> NUMBER .

    COMMA           reduce using rule 66 (literal -> NUMBER .)
    SEMICOLON       reduce using rule 66 (literal -> NUMBER .)
    PLUS            reduce using rule 66 (literal -> NUMBER .)
    MINUS           reduce using rule 66 (literal -> NUMBER .)
    MULT            reduce using rule 66 (literal -> NUMBER .)
    DIVIDE          reduce using rule 66 (literal -> NUMBER .)
    MOD             reduce using rule 66 (literal -> NUMBER .)
    EQUALS          reduce using rule 66 (literal -> NUMBER .)
    DIFFERENT       reduce using rule 66 (literal -> NUMBER .)
    GT              reduce using rule 66 (literal -> NUMBER .)
    GTE             reduce using rule 66 (literal -> NUMBER .)
    LT              reduce using rule 66 (literal -> NUMBER .)
    LTE             reduce using rule 66 (literal -> NUMBER .)
    AND             reduce using rule 66 (literal -> NUMBER .)
    OR              reduce using rule 66 (literal -> NUMBER .)
    QMARK           reduce using rule 66 (literal -> NUMBER .)
    RKEY            reduce using rule 66 (literal -> NUMBER .)
    RPAREN          reduce using rule 66 (literal -> NUMBER .)
    RCOR            reduce using rule 66 (literal -> NUMBER .)
    COLON           reduce using rule 66 (literal -> NUMBER .)


state 31

    (67) literal -> STRING_LITERAL .

    COMMA           reduce using rule 67 (literal -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 67 (literal -> STRING_LITERAL .)
    PLUS            reduce using rule 67 (literal -> STRING_LITERAL .)
    MINUS           reduce using rule 67 (literal -> STRING_LITERAL .)
    MULT            reduce using rule 67 (literal -> STRING_LITERAL .)
    DIVIDE          reduce using rule 67 (literal -> STRING_LITERAL .)
    MOD             reduce using rule 67 (literal -> STRING_LITERAL .)
    EQUALS          reduce using rule 67 (literal -> STRING_LITERAL .)
    DIFFERENT       reduce using rule 67 (literal -> STRING_LITERAL .)
    GT              reduce using rule 67 (literal -> STRING_LITERAL .)
    GTE             reduce using rule 67 (literal -> STRING_LITERAL .)
    LT              reduce using rule 67 (literal -> STRING_LITERAL .)
    LTE             reduce using rule 67 (literal -> STRING_LITERAL .)
    AND             reduce using rule 67 (literal -> STRING_LITERAL .)
    OR              reduce using rule 67 (literal -> STRING_LITERAL .)
    QMARK           reduce using rule 67 (literal -> STRING_LITERAL .)
    RKEY            reduce using rule 67 (literal -> STRING_LITERAL .)
    RPAREN          reduce using rule 67 (literal -> STRING_LITERAL .)
    RCOR            reduce using rule 67 (literal -> STRING_LITERAL .)
    COLON           reduce using rule 67 (literal -> STRING_LITERAL .)


state 32

    (68) literal -> FALSE .

    COMMA           reduce using rule 68 (literal -> FALSE .)
    SEMICOLON       reduce using rule 68 (literal -> FALSE .)
    PLUS            reduce using rule 68 (literal -> FALSE .)
    MINUS           reduce using rule 68 (literal -> FALSE .)
    MULT            reduce using rule 68 (literal -> FALSE .)
    DIVIDE          reduce using rule 68 (literal -> FALSE .)
    MOD             reduce using rule 68 (literal -> FALSE .)
    EQUALS          reduce using rule 68 (literal -> FALSE .)
    DIFFERENT       reduce using rule 68 (literal -> FALSE .)
    GT              reduce using rule 68 (literal -> FALSE .)
    GTE             reduce using rule 68 (literal -> FALSE .)
    LT              reduce using rule 68 (literal -> FALSE .)
    LTE             reduce using rule 68 (literal -> FALSE .)
    AND             reduce using rule 68 (literal -> FALSE .)
    OR              reduce using rule 68 (literal -> FALSE .)
    QMARK           reduce using rule 68 (literal -> FALSE .)
    RKEY            reduce using rule 68 (literal -> FALSE .)
    RPAREN          reduce using rule 68 (literal -> FALSE .)
    RCOR            reduce using rule 68 (literal -> FALSE .)
    COLON           reduce using rule 68 (literal -> FALSE .)


state 33

    (69) literal -> TRUE .

    COMMA           reduce using rule 69 (literal -> TRUE .)
    SEMICOLON       reduce using rule 69 (literal -> TRUE .)
    PLUS            reduce using rule 69 (literal -> TRUE .)
    MINUS           reduce using rule 69 (literal -> TRUE .)
    MULT            reduce using rule 69 (literal -> TRUE .)
    DIVIDE          reduce using rule 69 (literal -> TRUE .)
    MOD             reduce using rule 69 (literal -> TRUE .)
    EQUALS          reduce using rule 69 (literal -> TRUE .)
    DIFFERENT       reduce using rule 69 (literal -> TRUE .)
    GT              reduce using rule 69 (literal -> TRUE .)
    GTE             reduce using rule 69 (literal -> TRUE .)
    LT              reduce using rule 69 (literal -> TRUE .)
    LTE             reduce using rule 69 (literal -> TRUE .)
    AND             reduce using rule 69 (literal -> TRUE .)
    OR              reduce using rule 69 (literal -> TRUE .)
    QMARK           reduce using rule 69 (literal -> TRUE .)
    RKEY            reduce using rule 69 (literal -> TRUE .)
    RPAREN          reduce using rule 69 (literal -> TRUE .)
    RCOR            reduce using rule 69 (literal -> TRUE .)
    COLON           reduce using rule 69 (literal -> TRUE .)


state 34

    (12) varSpec -> ID LCOR NUMBER . RCOR
    (13) varSpec -> ID LCOR NUMBER . RCOR ASSIGN LKEY literalSeq RKEY

    RCOR            shift and go to state 41


state 35

    (9) varSpecSeq -> varSpec COMMA varSpecSeq .

    SEMICOLON       reduce using rule 9 (varSpecSeq -> varSpec COMMA varSpecSeq .)


state 36

    (10) varSpec -> ID .
    (11) varSpec -> ID . ASSIGN literal
    (12) varSpec -> ID . LCOR NUMBER RCOR
    (13) varSpec -> ID . LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    COMMA           reduce using rule 10 (varSpec -> ID .)
    SEMICOLON       reduce using rule 10 (varSpec -> ID .)
    ASSIGN          shift and go to state 21
    LCOR            shift and go to state 22


state 37

    (3) dec -> ID LPAREN paramList RPAREN LKEY . block RKEY
    (17) block -> . varDecList stmtList
    (76) varDecList -> . varDec varDecList
    (77) varDecList -> . empty
    (7) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    block                          shift and go to state 42
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 38

    (73) paramSeq -> param COMMA paramSeq .

    RPAREN          reduce using rule 73 (paramSeq -> param COMMA paramSeq .)


state 39

    (75) param -> type ID LCOR . RCOR

    RCOR            shift and go to state 47


state 40

    (4) dec -> type ID LPAREN paramList RPAREN . LKEY block RKEY

    LKEY            shift and go to state 48


state 41

    (12) varSpec -> ID LCOR NUMBER RCOR .
    (13) varSpec -> ID LCOR NUMBER RCOR . ASSIGN LKEY literalSeq RKEY

    COMMA           reduce using rule 12 (varSpec -> ID LCOR NUMBER RCOR .)
    SEMICOLON       reduce using rule 12 (varSpec -> ID LCOR NUMBER RCOR .)
    ASSIGN          shift and go to state 49


state 42

    (3) dec -> ID LPAREN paramList RPAREN LKEY block . RKEY

    RKEY            shift and go to state 50


state 43

    (17) block -> varDecList . stmtList
    (78) stmtList -> . stmt stmtList
    (79) stmtList -> . empty
    (18) stmt -> . ifStmt
    (19) stmt -> . whileStmt
    (20) stmt -> . forStmt
    (21) stmt -> . breakStmt
    (22) stmt -> . returnStmt
    (23) stmt -> . readStmt
    (24) stmt -> . writeStmt
    (25) stmt -> . assign SEMICOLON
    (26) stmt -> . subCall SEMICOLON
    (27) stmt -> . error
    (86) empty -> .
    (28) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY
    (29) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (30) whileStmt -> . WHILE LPAREN exp RPAREN LKEY block RKEY
    (31) forStmt -> . FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
    (32) breakStmt -> . BREAK SEMICOLON
    (35) returnStmt -> . RETURN SEMICOLON
    (36) returnStmt -> . RETURN exp SEMICOLON
    (33) readStmt -> . READ var SEMICOLON
    (34) writeStmt -> . WRITE expList SEMICOLON
    (38) assign -> . var ASSIGN exp
    (39) assign -> . var PLUSASSIGN exp
    (40) assign -> . var MINUSASSIGN exp
    (41) assign -> . var MULTASSIGN exp
    (42) assign -> . var DIVIDEASSIGN exp
    (43) assign -> . var MODASSIGN exp
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR

    error           shift and go to state 63
    RKEY            reduce using rule 86 (empty -> .)
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    BREAK           shift and go to state 67
    RETURN          shift and go to state 68
    READ            shift and go to state 69
    WRITE           shift and go to state 71
    ID              shift and go to state 72

    stmtList                       shift and go to state 51
    stmt                           shift and go to state 52
    empty                          shift and go to state 53
    ifStmt                         shift and go to state 54
    whileStmt                      shift and go to state 55
    forStmt                        shift and go to state 56
    breakStmt                      shift and go to state 57
    returnStmt                     shift and go to state 58
    readStmt                       shift and go to state 59
    writeStmt                      shift and go to state 60
    assign                         shift and go to state 61
    subCall                        shift and go to state 62
    var                            shift and go to state 70

state 44

    (76) varDecList -> varDec . varDecList
    (76) varDecList -> . varDec varDecList
    (77) varDecList -> . empty
    (7) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    varDec                         shift and go to state 44
    varDecList                     shift and go to state 73
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 45

    (77) varDecList -> empty .

    error           reduce using rule 77 (varDecList -> empty .)
    IF              reduce using rule 77 (varDecList -> empty .)
    WHILE           reduce using rule 77 (varDecList -> empty .)
    FOR             reduce using rule 77 (varDecList -> empty .)
    BREAK           reduce using rule 77 (varDecList -> empty .)
    RETURN          reduce using rule 77 (varDecList -> empty .)
    READ            reduce using rule 77 (varDecList -> empty .)
    WRITE           reduce using rule 77 (varDecList -> empty .)
    ID              reduce using rule 77 (varDecList -> empty .)
    RKEY            reduce using rule 77 (varDecList -> empty .)


state 46

    (7) varDec -> type . varSpecSeq SEMICOLON
    (8) varSpecSeq -> . varSpec
    (9) varSpecSeq -> . varSpec COMMA varSpecSeq
    (10) varSpec -> . ID
    (11) varSpec -> . ID ASSIGN literal
    (12) varSpec -> . ID LCOR NUMBER RCOR
    (13) varSpec -> . ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    ID              shift and go to state 36

    varSpecSeq                     shift and go to state 13
    varSpec                        shift and go to state 14

state 47

    (75) param -> type ID LCOR RCOR .

    COMMA           reduce using rule 75 (param -> type ID LCOR RCOR .)
    RPAREN          reduce using rule 75 (param -> type ID LCOR RCOR .)


state 48

    (4) dec -> type ID LPAREN paramList RPAREN LKEY . block RKEY
    (17) block -> . varDecList stmtList
    (76) varDecList -> . varDec varDecList
    (77) varDecList -> . empty
    (7) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    type                           shift and go to state 46
    block                          shift and go to state 74
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45

state 49

    (13) varSpec -> ID LCOR NUMBER RCOR ASSIGN . LKEY literalSeq RKEY

    LKEY            shift and go to state 75


state 50

    (3) dec -> ID LPAREN paramList RPAREN LKEY block RKEY .

    ID              reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    INT             reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    STRING          reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    BOOLEAN         reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    $end            reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)


state 51

    (17) block -> varDecList stmtList .

    RKEY            reduce using rule 17 (block -> varDecList stmtList .)


state 52

    (78) stmtList -> stmt . stmtList
    (78) stmtList -> . stmt stmtList
    (79) stmtList -> . empty
    (18) stmt -> . ifStmt
    (19) stmt -> . whileStmt
    (20) stmt -> . forStmt
    (21) stmt -> . breakStmt
    (22) stmt -> . returnStmt
    (23) stmt -> . readStmt
    (24) stmt -> . writeStmt
    (25) stmt -> . assign SEMICOLON
    (26) stmt -> . subCall SEMICOLON
    (27) stmt -> . error
    (86) empty -> .
    (28) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY
    (29) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (30) whileStmt -> . WHILE LPAREN exp RPAREN LKEY block RKEY
    (31) forStmt -> . FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
    (32) breakStmt -> . BREAK SEMICOLON
    (35) returnStmt -> . RETURN SEMICOLON
    (36) returnStmt -> . RETURN exp SEMICOLON
    (33) readStmt -> . READ var SEMICOLON
    (34) writeStmt -> . WRITE expList SEMICOLON
    (38) assign -> . var ASSIGN exp
    (39) assign -> . var PLUSASSIGN exp
    (40) assign -> . var MINUSASSIGN exp
    (41) assign -> . var MULTASSIGN exp
    (42) assign -> . var DIVIDEASSIGN exp
    (43) assign -> . var MODASSIGN exp
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR

    error           shift and go to state 63
    RKEY            reduce using rule 86 (empty -> .)
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    BREAK           shift and go to state 67
    RETURN          shift and go to state 68
    READ            shift and go to state 69
    WRITE           shift and go to state 71
    ID              shift and go to state 72

    stmt                           shift and go to state 52
    stmtList                       shift and go to state 76
    empty                          shift and go to state 53
    ifStmt                         shift and go to state 54
    whileStmt                      shift and go to state 55
    forStmt                        shift and go to state 56
    breakStmt                      shift and go to state 57
    returnStmt                     shift and go to state 58
    readStmt                       shift and go to state 59
    writeStmt                      shift and go to state 60
    assign                         shift and go to state 61
    subCall                        shift and go to state 62
    var                            shift and go to state 70

state 53

    (79) stmtList -> empty .

    RKEY            reduce using rule 79 (stmtList -> empty .)


state 54

    (18) stmt -> ifStmt .

    error           reduce using rule 18 (stmt -> ifStmt .)
    IF              reduce using rule 18 (stmt -> ifStmt .)
    WHILE           reduce using rule 18 (stmt -> ifStmt .)
    FOR             reduce using rule 18 (stmt -> ifStmt .)
    BREAK           reduce using rule 18 (stmt -> ifStmt .)
    RETURN          reduce using rule 18 (stmt -> ifStmt .)
    READ            reduce using rule 18 (stmt -> ifStmt .)
    WRITE           reduce using rule 18 (stmt -> ifStmt .)
    ID              reduce using rule 18 (stmt -> ifStmt .)
    RKEY            reduce using rule 18 (stmt -> ifStmt .)


state 55

    (19) stmt -> whileStmt .

    error           reduce using rule 19 (stmt -> whileStmt .)
    IF              reduce using rule 19 (stmt -> whileStmt .)
    WHILE           reduce using rule 19 (stmt -> whileStmt .)
    FOR             reduce using rule 19 (stmt -> whileStmt .)
    BREAK           reduce using rule 19 (stmt -> whileStmt .)
    RETURN          reduce using rule 19 (stmt -> whileStmt .)
    READ            reduce using rule 19 (stmt -> whileStmt .)
    WRITE           reduce using rule 19 (stmt -> whileStmt .)
    ID              reduce using rule 19 (stmt -> whileStmt .)
    RKEY            reduce using rule 19 (stmt -> whileStmt .)


state 56

    (20) stmt -> forStmt .

    error           reduce using rule 20 (stmt -> forStmt .)
    IF              reduce using rule 20 (stmt -> forStmt .)
    WHILE           reduce using rule 20 (stmt -> forStmt .)
    FOR             reduce using rule 20 (stmt -> forStmt .)
    BREAK           reduce using rule 20 (stmt -> forStmt .)
    RETURN          reduce using rule 20 (stmt -> forStmt .)
    READ            reduce using rule 20 (stmt -> forStmt .)
    WRITE           reduce using rule 20 (stmt -> forStmt .)
    ID              reduce using rule 20 (stmt -> forStmt .)
    RKEY            reduce using rule 20 (stmt -> forStmt .)


state 57

    (21) stmt -> breakStmt .

    error           reduce using rule 21 (stmt -> breakStmt .)
    IF              reduce using rule 21 (stmt -> breakStmt .)
    WHILE           reduce using rule 21 (stmt -> breakStmt .)
    FOR             reduce using rule 21 (stmt -> breakStmt .)
    BREAK           reduce using rule 21 (stmt -> breakStmt .)
    RETURN          reduce using rule 21 (stmt -> breakStmt .)
    READ            reduce using rule 21 (stmt -> breakStmt .)
    WRITE           reduce using rule 21 (stmt -> breakStmt .)
    ID              reduce using rule 21 (stmt -> breakStmt .)
    RKEY            reduce using rule 21 (stmt -> breakStmt .)


state 58

    (22) stmt -> returnStmt .

    error           reduce using rule 22 (stmt -> returnStmt .)
    IF              reduce using rule 22 (stmt -> returnStmt .)
    WHILE           reduce using rule 22 (stmt -> returnStmt .)
    FOR             reduce using rule 22 (stmt -> returnStmt .)
    BREAK           reduce using rule 22 (stmt -> returnStmt .)
    RETURN          reduce using rule 22 (stmt -> returnStmt .)
    READ            reduce using rule 22 (stmt -> returnStmt .)
    WRITE           reduce using rule 22 (stmt -> returnStmt .)
    ID              reduce using rule 22 (stmt -> returnStmt .)
    RKEY            reduce using rule 22 (stmt -> returnStmt .)


state 59

    (23) stmt -> readStmt .

    error           reduce using rule 23 (stmt -> readStmt .)
    IF              reduce using rule 23 (stmt -> readStmt .)
    WHILE           reduce using rule 23 (stmt -> readStmt .)
    FOR             reduce using rule 23 (stmt -> readStmt .)
    BREAK           reduce using rule 23 (stmt -> readStmt .)
    RETURN          reduce using rule 23 (stmt -> readStmt .)
    READ            reduce using rule 23 (stmt -> readStmt .)
    WRITE           reduce using rule 23 (stmt -> readStmt .)
    ID              reduce using rule 23 (stmt -> readStmt .)
    RKEY            reduce using rule 23 (stmt -> readStmt .)


state 60

    (24) stmt -> writeStmt .

    error           reduce using rule 24 (stmt -> writeStmt .)
    IF              reduce using rule 24 (stmt -> writeStmt .)
    WHILE           reduce using rule 24 (stmt -> writeStmt .)
    FOR             reduce using rule 24 (stmt -> writeStmt .)
    BREAK           reduce using rule 24 (stmt -> writeStmt .)
    RETURN          reduce using rule 24 (stmt -> writeStmt .)
    READ            reduce using rule 24 (stmt -> writeStmt .)
    WRITE           reduce using rule 24 (stmt -> writeStmt .)
    ID              reduce using rule 24 (stmt -> writeStmt .)
    RKEY            reduce using rule 24 (stmt -> writeStmt .)


state 61

    (25) stmt -> assign . SEMICOLON

    SEMICOLON       shift and go to state 77


state 62

    (26) stmt -> subCall . SEMICOLON

    SEMICOLON       shift and go to state 78


state 63

    (27) stmt -> error .

    error           reduce using rule 27 (stmt -> error .)
    IF              reduce using rule 27 (stmt -> error .)
    WHILE           reduce using rule 27 (stmt -> error .)
    FOR             reduce using rule 27 (stmt -> error .)
    BREAK           reduce using rule 27 (stmt -> error .)
    RETURN          reduce using rule 27 (stmt -> error .)
    READ            reduce using rule 27 (stmt -> error .)
    WRITE           reduce using rule 27 (stmt -> error .)
    ID              reduce using rule 27 (stmt -> error .)
    RKEY            reduce using rule 27 (stmt -> error .)


state 64

    (28) ifStmt -> IF . LPAREN exp RPAREN LKEY block RKEY
    (29) ifStmt -> IF . LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY

    LPAREN          shift and go to state 79


state 65

    (30) whileStmt -> WHILE . LPAREN exp RPAREN LKEY block RKEY

    LPAREN          shift and go to state 80


state 66

    (31) forStmt -> FOR . LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY

    LPAREN          shift and go to state 81


state 67

    (32) breakStmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 82


state 68

    (35) returnStmt -> RETURN . SEMICOLON
    (36) returnStmt -> RETURN . exp SEMICOLON
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    SEMICOLON       shift and go to state 83
    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 84
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 69

    (33) readStmt -> READ . var SEMICOLON
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR

    ID              shift and go to state 92

    var                            shift and go to state 91

state 70

    (38) assign -> var . ASSIGN exp
    (39) assign -> var . PLUSASSIGN exp
    (40) assign -> var . MINUSASSIGN exp
    (41) assign -> var . MULTASSIGN exp
    (42) assign -> var . DIVIDEASSIGN exp
    (43) assign -> var . MODASSIGN exp

    ASSIGN          shift and go to state 93
    PLUSASSIGN      shift and go to state 94
    MINUSASSIGN     shift and go to state 95
    MULTASSIGN      shift and go to state 96
    DIVIDEASSIGN    shift and go to state 97
    MODASSIGN       shift and go to state 98


state 71

    (34) writeStmt -> WRITE . expList SEMICOLON
    (82) expList -> . expSeq
    (83) expList -> . empty
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (86) empty -> .
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    SEMICOLON       reduce using rule 86 (empty -> .)
    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    expList                        shift and go to state 99
    expSeq                         shift and go to state 100
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 72

    (37) subCall -> ID . LPAREN expList RPAREN
    (64) var -> ID .
    (65) var -> ID . LCOR exp RCOR

    LPAREN          shift and go to state 103
    ASSIGN          reduce using rule 64 (var -> ID .)
    PLUSASSIGN      reduce using rule 64 (var -> ID .)
    MINUSASSIGN     reduce using rule 64 (var -> ID .)
    MULTASSIGN      reduce using rule 64 (var -> ID .)
    DIVIDEASSIGN    reduce using rule 64 (var -> ID .)
    MODASSIGN       reduce using rule 64 (var -> ID .)
    SEMICOLON       reduce using rule 64 (var -> ID .)
    PLUS            reduce using rule 64 (var -> ID .)
    MINUS           reduce using rule 64 (var -> ID .)
    MULT            reduce using rule 64 (var -> ID .)
    DIVIDE          reduce using rule 64 (var -> ID .)
    MOD             reduce using rule 64 (var -> ID .)
    EQUALS          reduce using rule 64 (var -> ID .)
    DIFFERENT       reduce using rule 64 (var -> ID .)
    GT              reduce using rule 64 (var -> ID .)
    GTE             reduce using rule 64 (var -> ID .)
    LT              reduce using rule 64 (var -> ID .)
    LTE             reduce using rule 64 (var -> ID .)
    AND             reduce using rule 64 (var -> ID .)
    OR              reduce using rule 64 (var -> ID .)
    QMARK           reduce using rule 64 (var -> ID .)
    COMMA           reduce using rule 64 (var -> ID .)
    RPAREN          reduce using rule 64 (var -> ID .)
    RCOR            reduce using rule 64 (var -> ID .)
    COLON           reduce using rule 64 (var -> ID .)
    LCOR            shift and go to state 104


state 73

    (76) varDecList -> varDec varDecList .

    error           reduce using rule 76 (varDecList -> varDec varDecList .)
    IF              reduce using rule 76 (varDecList -> varDec varDecList .)
    WHILE           reduce using rule 76 (varDecList -> varDec varDecList .)
    FOR             reduce using rule 76 (varDecList -> varDec varDecList .)
    BREAK           reduce using rule 76 (varDecList -> varDec varDecList .)
    RETURN          reduce using rule 76 (varDecList -> varDec varDecList .)
    READ            reduce using rule 76 (varDecList -> varDec varDecList .)
    WRITE           reduce using rule 76 (varDecList -> varDec varDecList .)
    ID              reduce using rule 76 (varDecList -> varDec varDecList .)
    RKEY            reduce using rule 76 (varDecList -> varDec varDecList .)


state 74

    (4) dec -> type ID LPAREN paramList RPAREN LKEY block . RKEY

    RKEY            shift and go to state 105


state 75

    (13) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY . literalSeq RKEY
    (80) literalSeq -> . literal
    (81) literalSeq -> . literal COMMA literalSeq
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    literalSeq                     shift and go to state 106
    literal                        shift and go to state 107

state 76

    (78) stmtList -> stmt stmtList .

    RKEY            reduce using rule 78 (stmtList -> stmt stmtList .)


state 77

    (25) stmt -> assign SEMICOLON .

    error           reduce using rule 25 (stmt -> assign SEMICOLON .)
    IF              reduce using rule 25 (stmt -> assign SEMICOLON .)
    WHILE           reduce using rule 25 (stmt -> assign SEMICOLON .)
    FOR             reduce using rule 25 (stmt -> assign SEMICOLON .)
    BREAK           reduce using rule 25 (stmt -> assign SEMICOLON .)
    RETURN          reduce using rule 25 (stmt -> assign SEMICOLON .)
    READ            reduce using rule 25 (stmt -> assign SEMICOLON .)
    WRITE           reduce using rule 25 (stmt -> assign SEMICOLON .)
    ID              reduce using rule 25 (stmt -> assign SEMICOLON .)
    RKEY            reduce using rule 25 (stmt -> assign SEMICOLON .)


state 78

    (26) stmt -> subCall SEMICOLON .

    error           reduce using rule 26 (stmt -> subCall SEMICOLON .)
    IF              reduce using rule 26 (stmt -> subCall SEMICOLON .)
    WHILE           reduce using rule 26 (stmt -> subCall SEMICOLON .)
    FOR             reduce using rule 26 (stmt -> subCall SEMICOLON .)
    BREAK           reduce using rule 26 (stmt -> subCall SEMICOLON .)
    RETURN          reduce using rule 26 (stmt -> subCall SEMICOLON .)
    READ            reduce using rule 26 (stmt -> subCall SEMICOLON .)
    WRITE           reduce using rule 26 (stmt -> subCall SEMICOLON .)
    ID              reduce using rule 26 (stmt -> subCall SEMICOLON .)
    RKEY            reduce using rule 26 (stmt -> subCall SEMICOLON .)


state 79

    (28) ifStmt -> IF LPAREN . exp RPAREN LKEY block RKEY
    (29) ifStmt -> IF LPAREN . exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 108
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 80

    (30) whileStmt -> WHILE LPAREN . exp RPAREN LKEY block RKEY
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 109
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 81

    (31) forStmt -> FOR LPAREN . assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
    (38) assign -> . var ASSIGN exp
    (39) assign -> . var PLUSASSIGN exp
    (40) assign -> . var MINUSASSIGN exp
    (41) assign -> . var MULTASSIGN exp
    (42) assign -> . var DIVIDEASSIGN exp
    (43) assign -> . var MODASSIGN exp
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR

    ID              shift and go to state 92

    assign                         shift and go to state 110
    var                            shift and go to state 70

state 82

    (32) breakStmt -> BREAK SEMICOLON .

    error           reduce using rule 32 (breakStmt -> BREAK SEMICOLON .)
    IF              reduce using rule 32 (breakStmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 32 (breakStmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 32 (breakStmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 32 (breakStmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 32 (breakStmt -> BREAK SEMICOLON .)
    READ            reduce using rule 32 (breakStmt -> BREAK SEMICOLON .)
    WRITE           reduce using rule 32 (breakStmt -> BREAK SEMICOLON .)
    ID              reduce using rule 32 (breakStmt -> BREAK SEMICOLON .)
    RKEY            reduce using rule 32 (breakStmt -> BREAK SEMICOLON .)


state 83

    (35) returnStmt -> RETURN SEMICOLON .

    error           reduce using rule 35 (returnStmt -> RETURN SEMICOLON .)
    IF              reduce using rule 35 (returnStmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 35 (returnStmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 35 (returnStmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 35 (returnStmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 35 (returnStmt -> RETURN SEMICOLON .)
    READ            reduce using rule 35 (returnStmt -> RETURN SEMICOLON .)
    WRITE           reduce using rule 35 (returnStmt -> RETURN SEMICOLON .)
    ID              reduce using rule 35 (returnStmt -> RETURN SEMICOLON .)
    RKEY            reduce using rule 35 (returnStmt -> RETURN SEMICOLON .)


state 84

    (36) returnStmt -> RETURN exp . SEMICOLON
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    SEMICOLON       shift and go to state 111
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 85

    (57) exp -> NOT . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 126
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 86

    (58) exp -> UMINUS . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 127
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 87

    (60) exp -> subCall .

    SEMICOLON       reduce using rule 60 (exp -> subCall .)
    PLUS            reduce using rule 60 (exp -> subCall .)
    MINUS           reduce using rule 60 (exp -> subCall .)
    MULT            reduce using rule 60 (exp -> subCall .)
    DIVIDE          reduce using rule 60 (exp -> subCall .)
    MOD             reduce using rule 60 (exp -> subCall .)
    EQUALS          reduce using rule 60 (exp -> subCall .)
    DIFFERENT       reduce using rule 60 (exp -> subCall .)
    GT              reduce using rule 60 (exp -> subCall .)
    GTE             reduce using rule 60 (exp -> subCall .)
    LT              reduce using rule 60 (exp -> subCall .)
    LTE             reduce using rule 60 (exp -> subCall .)
    AND             reduce using rule 60 (exp -> subCall .)
    OR              reduce using rule 60 (exp -> subCall .)
    QMARK           reduce using rule 60 (exp -> subCall .)
    COMMA           reduce using rule 60 (exp -> subCall .)
    RPAREN          reduce using rule 60 (exp -> subCall .)
    RCOR            reduce using rule 60 (exp -> subCall .)
    COLON           reduce using rule 60 (exp -> subCall .)


state 88

    (61) exp -> var .

    SEMICOLON       reduce using rule 61 (exp -> var .)
    PLUS            reduce using rule 61 (exp -> var .)
    MINUS           reduce using rule 61 (exp -> var .)
    MULT            reduce using rule 61 (exp -> var .)
    DIVIDE          reduce using rule 61 (exp -> var .)
    MOD             reduce using rule 61 (exp -> var .)
    EQUALS          reduce using rule 61 (exp -> var .)
    DIFFERENT       reduce using rule 61 (exp -> var .)
    GT              reduce using rule 61 (exp -> var .)
    GTE             reduce using rule 61 (exp -> var .)
    LT              reduce using rule 61 (exp -> var .)
    LTE             reduce using rule 61 (exp -> var .)
    AND             reduce using rule 61 (exp -> var .)
    OR              reduce using rule 61 (exp -> var .)
    QMARK           reduce using rule 61 (exp -> var .)
    COMMA           reduce using rule 61 (exp -> var .)
    RPAREN          reduce using rule 61 (exp -> var .)
    RCOR            reduce using rule 61 (exp -> var .)
    COLON           reduce using rule 61 (exp -> var .)


state 89

    (62) exp -> literal .

    SEMICOLON       reduce using rule 62 (exp -> literal .)
    PLUS            reduce using rule 62 (exp -> literal .)
    MINUS           reduce using rule 62 (exp -> literal .)
    MULT            reduce using rule 62 (exp -> literal .)
    DIVIDE          reduce using rule 62 (exp -> literal .)
    MOD             reduce using rule 62 (exp -> literal .)
    EQUALS          reduce using rule 62 (exp -> literal .)
    DIFFERENT       reduce using rule 62 (exp -> literal .)
    GT              reduce using rule 62 (exp -> literal .)
    GTE             reduce using rule 62 (exp -> literal .)
    LT              reduce using rule 62 (exp -> literal .)
    LTE             reduce using rule 62 (exp -> literal .)
    AND             reduce using rule 62 (exp -> literal .)
    OR              reduce using rule 62 (exp -> literal .)
    QMARK           reduce using rule 62 (exp -> literal .)
    COMMA           reduce using rule 62 (exp -> literal .)
    RPAREN          reduce using rule 62 (exp -> literal .)
    RCOR            reduce using rule 62 (exp -> literal .)
    COLON           reduce using rule 62 (exp -> literal .)


state 90

    (63) exp -> LPAREN . exp RPAREN
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 128
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 91

    (33) readStmt -> READ var . SEMICOLON

    SEMICOLON       shift and go to state 129


state 92

    (64) var -> ID .
    (65) var -> ID . LCOR exp RCOR

    SEMICOLON       reduce using rule 64 (var -> ID .)
    ASSIGN          reduce using rule 64 (var -> ID .)
    PLUSASSIGN      reduce using rule 64 (var -> ID .)
    MINUSASSIGN     reduce using rule 64 (var -> ID .)
    MULTASSIGN      reduce using rule 64 (var -> ID .)
    DIVIDEASSIGN    reduce using rule 64 (var -> ID .)
    MODASSIGN       reduce using rule 64 (var -> ID .)
    LCOR            shift and go to state 104


state 93

    (38) assign -> var ASSIGN . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 130
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 94

    (39) assign -> var PLUSASSIGN . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 131
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 95

    (40) assign -> var MINUSASSIGN . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 132
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 96

    (41) assign -> var MULTASSIGN . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 133
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 97

    (42) assign -> var DIVIDEASSIGN . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 134
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 98

    (43) assign -> var MODASSIGN . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 135
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 99

    (34) writeStmt -> WRITE expList . SEMICOLON

    SEMICOLON       shift and go to state 136


state 100

    (82) expList -> expSeq .

    SEMICOLON       reduce using rule 82 (expList -> expSeq .)
    RPAREN          reduce using rule 82 (expList -> expSeq .)


state 101

    (83) expList -> empty .

    SEMICOLON       reduce using rule 83 (expList -> empty .)
    RPAREN          reduce using rule 83 (expList -> empty .)


state 102

    (84) expSeq -> exp .
    (85) expSeq -> exp . COMMA expSeq
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    SEMICOLON       reduce using rule 84 (expSeq -> exp .)
    RPAREN          reduce using rule 84 (expSeq -> exp .)
    COMMA           shift and go to state 137
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 103

    (37) subCall -> ID LPAREN . expList RPAREN
    (82) expList -> . expSeq
    (83) expList -> . empty
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (86) empty -> .
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    RPAREN          reduce using rule 86 (empty -> .)
    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    expList                        shift and go to state 138
    expSeq                         shift and go to state 100
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 104

    (65) var -> ID LCOR . exp RCOR
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 139
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 105

    (4) dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .

    ID              reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    INT             reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    STRING          reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    BOOLEAN         reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    $end            reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)


state 106

    (13) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq . RKEY

    RKEY            shift and go to state 140


state 107

    (80) literalSeq -> literal .
    (81) literalSeq -> literal . COMMA literalSeq

    RKEY            reduce using rule 80 (literalSeq -> literal .)
    COMMA           shift and go to state 141


state 108

    (28) ifStmt -> IF LPAREN exp . RPAREN LKEY block RKEY
    (29) ifStmt -> IF LPAREN exp . RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    RPAREN          shift and go to state 142
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 109

    (30) whileStmt -> WHILE LPAREN exp . RPAREN LKEY block RKEY
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    RPAREN          shift and go to state 143
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 110

    (31) forStmt -> FOR LPAREN assign . SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY

    SEMICOLON       shift and go to state 144


state 111

    (36) returnStmt -> RETURN exp SEMICOLON .

    error           reduce using rule 36 (returnStmt -> RETURN exp SEMICOLON .)
    IF              reduce using rule 36 (returnStmt -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 36 (returnStmt -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 36 (returnStmt -> RETURN exp SEMICOLON .)
    BREAK           reduce using rule 36 (returnStmt -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 36 (returnStmt -> RETURN exp SEMICOLON .)
    READ            reduce using rule 36 (returnStmt -> RETURN exp SEMICOLON .)
    WRITE           reduce using rule 36 (returnStmt -> RETURN exp SEMICOLON .)
    ID              reduce using rule 36 (returnStmt -> RETURN exp SEMICOLON .)
    RKEY            reduce using rule 36 (returnStmt -> RETURN exp SEMICOLON .)


state 112

    (44) exp -> exp PLUS . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 145
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 113

    (45) exp -> exp MINUS . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 146
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 114

    (46) exp -> exp MULT . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 147
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 115

    (47) exp -> exp DIVIDE . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 148
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 116

    (48) exp -> exp MOD . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 149
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 117

    (49) exp -> exp EQUALS . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 150
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 118

    (50) exp -> exp DIFFERENT . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 151
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 119

    (51) exp -> exp GT . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 152
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 120

    (52) exp -> exp GTE . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 153
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 121

    (53) exp -> exp LT . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 154
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 122

    (54) exp -> exp LTE . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 155
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 123

    (55) exp -> exp AND . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 156
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 124

    (56) exp -> exp OR . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 157
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 125

    (59) exp -> exp QMARK . exp COLON exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 158
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 126

    (57) exp -> NOT exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 57 (exp -> NOT exp .)
    COMMA           reduce using rule 57 (exp -> NOT exp .)
    RPAREN          reduce using rule 57 (exp -> NOT exp .)
    RCOR            reduce using rule 57 (exp -> NOT exp .)
    COLON           reduce using rule 57 (exp -> NOT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 57 (exp -> NOT exp .) ]
  ! MINUS           [ reduce using rule 57 (exp -> NOT exp .) ]
  ! MULT            [ reduce using rule 57 (exp -> NOT exp .) ]
  ! DIVIDE          [ reduce using rule 57 (exp -> NOT exp .) ]
  ! MOD             [ reduce using rule 57 (exp -> NOT exp .) ]
  ! EQUALS          [ reduce using rule 57 (exp -> NOT exp .) ]
  ! DIFFERENT       [ reduce using rule 57 (exp -> NOT exp .) ]
  ! GT              [ reduce using rule 57 (exp -> NOT exp .) ]
  ! GTE             [ reduce using rule 57 (exp -> NOT exp .) ]
  ! LT              [ reduce using rule 57 (exp -> NOT exp .) ]
  ! LTE             [ reduce using rule 57 (exp -> NOT exp .) ]
  ! AND             [ reduce using rule 57 (exp -> NOT exp .) ]
  ! OR              [ reduce using rule 57 (exp -> NOT exp .) ]
  ! QMARK           [ reduce using rule 57 (exp -> NOT exp .) ]


state 127

    (58) exp -> UMINUS exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 58 (exp -> UMINUS exp .)
    COMMA           reduce using rule 58 (exp -> UMINUS exp .)
    RPAREN          reduce using rule 58 (exp -> UMINUS exp .)
    RCOR            reduce using rule 58 (exp -> UMINUS exp .)
    COLON           reduce using rule 58 (exp -> UMINUS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! MINUS           [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! MULT            [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! DIVIDE          [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! MOD             [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! EQUALS          [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! DIFFERENT       [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! GT              [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! GTE             [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! LT              [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! LTE             [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! AND             [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! OR              [ reduce using rule 58 (exp -> UMINUS exp .) ]
  ! QMARK           [ reduce using rule 58 (exp -> UMINUS exp .) ]


state 128

    (63) exp -> LPAREN exp . RPAREN
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    RPAREN          shift and go to state 159
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 129

    (33) readStmt -> READ var SEMICOLON .

    error           reduce using rule 33 (readStmt -> READ var SEMICOLON .)
    IF              reduce using rule 33 (readStmt -> READ var SEMICOLON .)
    WHILE           reduce using rule 33 (readStmt -> READ var SEMICOLON .)
    FOR             reduce using rule 33 (readStmt -> READ var SEMICOLON .)
    BREAK           reduce using rule 33 (readStmt -> READ var SEMICOLON .)
    RETURN          reduce using rule 33 (readStmt -> READ var SEMICOLON .)
    READ            reduce using rule 33 (readStmt -> READ var SEMICOLON .)
    WRITE           reduce using rule 33 (readStmt -> READ var SEMICOLON .)
    ID              reduce using rule 33 (readStmt -> READ var SEMICOLON .)
    RKEY            reduce using rule 33 (readStmt -> READ var SEMICOLON .)


state 130

    (38) assign -> var ASSIGN exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    SEMICOLON       reduce using rule 38 (assign -> var ASSIGN exp .)
    RPAREN          reduce using rule 38 (assign -> var ASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 131

    (39) assign -> var PLUSASSIGN exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    SEMICOLON       reduce using rule 39 (assign -> var PLUSASSIGN exp .)
    RPAREN          reduce using rule 39 (assign -> var PLUSASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 132

    (40) assign -> var MINUSASSIGN exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    SEMICOLON       reduce using rule 40 (assign -> var MINUSASSIGN exp .)
    RPAREN          reduce using rule 40 (assign -> var MINUSASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 133

    (41) assign -> var MULTASSIGN exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    SEMICOLON       reduce using rule 41 (assign -> var MULTASSIGN exp .)
    RPAREN          reduce using rule 41 (assign -> var MULTASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 134

    (42) assign -> var DIVIDEASSIGN exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    SEMICOLON       reduce using rule 42 (assign -> var DIVIDEASSIGN exp .)
    RPAREN          reduce using rule 42 (assign -> var DIVIDEASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 135

    (43) assign -> var MODASSIGN exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    SEMICOLON       reduce using rule 43 (assign -> var MODASSIGN exp .)
    RPAREN          reduce using rule 43 (assign -> var MODASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 136

    (34) writeStmt -> WRITE expList SEMICOLON .

    error           reduce using rule 34 (writeStmt -> WRITE expList SEMICOLON .)
    IF              reduce using rule 34 (writeStmt -> WRITE expList SEMICOLON .)
    WHILE           reduce using rule 34 (writeStmt -> WRITE expList SEMICOLON .)
    FOR             reduce using rule 34 (writeStmt -> WRITE expList SEMICOLON .)
    BREAK           reduce using rule 34 (writeStmt -> WRITE expList SEMICOLON .)
    RETURN          reduce using rule 34 (writeStmt -> WRITE expList SEMICOLON .)
    READ            reduce using rule 34 (writeStmt -> WRITE expList SEMICOLON .)
    WRITE           reduce using rule 34 (writeStmt -> WRITE expList SEMICOLON .)
    ID              reduce using rule 34 (writeStmt -> WRITE expList SEMICOLON .)
    RKEY            reduce using rule 34 (writeStmt -> WRITE expList SEMICOLON .)


state 137

    (85) expSeq -> exp COMMA . expSeq
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 102
    expSeq                         shift and go to state 160
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 138

    (37) subCall -> ID LPAREN expList . RPAREN

    RPAREN          shift and go to state 161


state 139

    (65) var -> ID LCOR exp . RCOR
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    RCOR            shift and go to state 162
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 140

    (13) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .

    COMMA           reduce using rule 13 (varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .)
    SEMICOLON       reduce using rule 13 (varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .)


state 141

    (81) literalSeq -> literal COMMA . literalSeq
    (80) literalSeq -> . literal
    (81) literalSeq -> . literal COMMA literalSeq
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    literal                        shift and go to state 107
    literalSeq                     shift and go to state 163

state 142

    (28) ifStmt -> IF LPAREN exp RPAREN . LKEY block RKEY
    (29) ifStmt -> IF LPAREN exp RPAREN . LKEY block RKEY ELSE LKEY block RKEY

    LKEY            shift and go to state 164


state 143

    (30) whileStmt -> WHILE LPAREN exp RPAREN . LKEY block RKEY

    LKEY            shift and go to state 165


state 144

    (31) forStmt -> FOR LPAREN assign SEMICOLON . exp SEMICOLON assign RPAREN LKEY block RKEY
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 166
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 145

    (44) exp -> exp PLUS exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 44 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 44 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 44 (exp -> exp PLUS exp .)
    RCOR            reduce using rule 44 (exp -> exp PLUS exp .)
    COLON           reduce using rule 44 (exp -> exp PLUS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! MINUS           [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! MULT            [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! EQUALS          [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! DIFFERENT       [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! GT              [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! GTE             [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! LT              [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! LTE             [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! AND             [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! OR              [ reduce using rule 44 (exp -> exp PLUS exp .) ]
  ! QMARK           [ reduce using rule 44 (exp -> exp PLUS exp .) ]


state 146

    (45) exp -> exp MINUS exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 45 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 45 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 45 (exp -> exp MINUS exp .)
    RCOR            reduce using rule 45 (exp -> exp MINUS exp .)
    COLON           reduce using rule 45 (exp -> exp MINUS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! MINUS           [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! MULT            [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! EQUALS          [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! DIFFERENT       [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! GT              [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! GTE             [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! LT              [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! LTE             [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! AND             [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! OR              [ reduce using rule 45 (exp -> exp MINUS exp .) ]
  ! QMARK           [ reduce using rule 45 (exp -> exp MINUS exp .) ]


state 147

    (46) exp -> exp MULT exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 46 (exp -> exp MULT exp .)
    COMMA           reduce using rule 46 (exp -> exp MULT exp .)
    RPAREN          reduce using rule 46 (exp -> exp MULT exp .)
    RCOR            reduce using rule 46 (exp -> exp MULT exp .)
    COLON           reduce using rule 46 (exp -> exp MULT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! MINUS           [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! MULT            [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! DIVIDE          [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! MOD             [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! EQUALS          [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! DIFFERENT       [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! GT              [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! GTE             [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! LT              [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! LTE             [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! AND             [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! OR              [ reduce using rule 46 (exp -> exp MULT exp .) ]
  ! QMARK           [ reduce using rule 46 (exp -> exp MULT exp .) ]


state 148

    (47) exp -> exp DIVIDE exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 47 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 47 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 47 (exp -> exp DIVIDE exp .)
    RCOR            reduce using rule 47 (exp -> exp DIVIDE exp .)
    COLON           reduce using rule 47 (exp -> exp DIVIDE exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! MINUS           [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! MULT            [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! DIVIDE          [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! MOD             [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! EQUALS          [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! DIFFERENT       [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! GT              [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! GTE             [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! LT              [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! LTE             [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! AND             [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! OR              [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]
  ! QMARK           [ reduce using rule 47 (exp -> exp DIVIDE exp .) ]


state 149

    (48) exp -> exp MOD exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 48 (exp -> exp MOD exp .)
    COMMA           reduce using rule 48 (exp -> exp MOD exp .)
    RPAREN          reduce using rule 48 (exp -> exp MOD exp .)
    RCOR            reduce using rule 48 (exp -> exp MOD exp .)
    COLON           reduce using rule 48 (exp -> exp MOD exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! MINUS           [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! MULT            [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! DIVIDE          [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! MOD             [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! EQUALS          [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! DIFFERENT       [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! GT              [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! GTE             [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! LT              [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! LTE             [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! AND             [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! OR              [ reduce using rule 48 (exp -> exp MOD exp .) ]
  ! QMARK           [ reduce using rule 48 (exp -> exp MOD exp .) ]


state 150

    (49) exp -> exp EQUALS exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 49 (exp -> exp EQUALS exp .)
    COMMA           reduce using rule 49 (exp -> exp EQUALS exp .)
    RPAREN          reduce using rule 49 (exp -> exp EQUALS exp .)
    RCOR            reduce using rule 49 (exp -> exp EQUALS exp .)
    COLON           reduce using rule 49 (exp -> exp EQUALS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! MINUS           [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! MULT            [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! MOD             [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! EQUALS          [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! DIFFERENT       [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! GT              [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! GTE             [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! LT              [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! LTE             [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! AND             [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! OR              [ reduce using rule 49 (exp -> exp EQUALS exp .) ]
  ! QMARK           [ reduce using rule 49 (exp -> exp EQUALS exp .) ]


state 151

    (50) exp -> exp DIFFERENT exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 50 (exp -> exp DIFFERENT exp .)
    COMMA           reduce using rule 50 (exp -> exp DIFFERENT exp .)
    RPAREN          reduce using rule 50 (exp -> exp DIFFERENT exp .)
    RCOR            reduce using rule 50 (exp -> exp DIFFERENT exp .)
    COLON           reduce using rule 50 (exp -> exp DIFFERENT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! MINUS           [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! MULT            [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! DIVIDE          [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! MOD             [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! EQUALS          [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! DIFFERENT       [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! GT              [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! GTE             [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! LT              [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! LTE             [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! AND             [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! OR              [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]
  ! QMARK           [ reduce using rule 50 (exp -> exp DIFFERENT exp .) ]


state 152

    (51) exp -> exp GT exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 51 (exp -> exp GT exp .)
    COMMA           reduce using rule 51 (exp -> exp GT exp .)
    RPAREN          reduce using rule 51 (exp -> exp GT exp .)
    RCOR            reduce using rule 51 (exp -> exp GT exp .)
    COLON           reduce using rule 51 (exp -> exp GT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! MULT            [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! MOD             [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! EQUALS          [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! DIFFERENT       [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! GT              [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! GTE             [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! LT              [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! LTE             [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! AND             [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! OR              [ reduce using rule 51 (exp -> exp GT exp .) ]
  ! QMARK           [ reduce using rule 51 (exp -> exp GT exp .) ]


state 153

    (52) exp -> exp GTE exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 52 (exp -> exp GTE exp .)
    COMMA           reduce using rule 52 (exp -> exp GTE exp .)
    RPAREN          reduce using rule 52 (exp -> exp GTE exp .)
    RCOR            reduce using rule 52 (exp -> exp GTE exp .)
    COLON           reduce using rule 52 (exp -> exp GTE exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! MINUS           [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! MULT            [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! DIVIDE          [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! MOD             [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! EQUALS          [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! DIFFERENT       [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! GT              [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! GTE             [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! LT              [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! LTE             [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! AND             [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! OR              [ reduce using rule 52 (exp -> exp GTE exp .) ]
  ! QMARK           [ reduce using rule 52 (exp -> exp GTE exp .) ]


state 154

    (53) exp -> exp LT exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 53 (exp -> exp LT exp .)
    COMMA           reduce using rule 53 (exp -> exp LT exp .)
    RPAREN          reduce using rule 53 (exp -> exp LT exp .)
    RCOR            reduce using rule 53 (exp -> exp LT exp .)
    COLON           reduce using rule 53 (exp -> exp LT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! MULT            [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! MOD             [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! EQUALS          [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! DIFFERENT       [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! GT              [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! GTE             [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! LT              [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! LTE             [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! AND             [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! OR              [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! QMARK           [ reduce using rule 53 (exp -> exp LT exp .) ]


state 155

    (54) exp -> exp LTE exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 54 (exp -> exp LTE exp .)
    COMMA           reduce using rule 54 (exp -> exp LTE exp .)
    RPAREN          reduce using rule 54 (exp -> exp LTE exp .)
    RCOR            reduce using rule 54 (exp -> exp LTE exp .)
    COLON           reduce using rule 54 (exp -> exp LTE exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! MINUS           [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! MULT            [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! DIVIDE          [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! MOD             [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! EQUALS          [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! DIFFERENT       [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! GT              [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! GTE             [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! LT              [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! LTE             [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! AND             [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! OR              [ reduce using rule 54 (exp -> exp LTE exp .) ]
  ! QMARK           [ reduce using rule 54 (exp -> exp LTE exp .) ]


state 156

    (55) exp -> exp AND exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 55 (exp -> exp AND exp .)
    COMMA           reduce using rule 55 (exp -> exp AND exp .)
    RPAREN          reduce using rule 55 (exp -> exp AND exp .)
    RCOR            reduce using rule 55 (exp -> exp AND exp .)
    COLON           reduce using rule 55 (exp -> exp AND exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! MULT            [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! EQUALS          [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! DIFFERENT       [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! GTE             [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! LTE             [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! AND             [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! OR              [ reduce using rule 55 (exp -> exp AND exp .) ]
  ! QMARK           [ reduce using rule 55 (exp -> exp AND exp .) ]


state 157

    (56) exp -> exp OR exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 56 (exp -> exp OR exp .)
    COMMA           reduce using rule 56 (exp -> exp OR exp .)
    RPAREN          reduce using rule 56 (exp -> exp OR exp .)
    RCOR            reduce using rule 56 (exp -> exp OR exp .)
    COLON           reduce using rule 56 (exp -> exp OR exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! MULT            [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! EQUALS          [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! DIFFERENT       [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! GTE             [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! LTE             [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! OR              [ reduce using rule 56 (exp -> exp OR exp .) ]
  ! QMARK           [ reduce using rule 56 (exp -> exp OR exp .) ]


state 158

    (59) exp -> exp QMARK exp . COLON exp
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    COLON           shift and go to state 167
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 159

    (63) exp -> LPAREN exp RPAREN .

    SEMICOLON       reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    MULT            reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    MOD             reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    EQUALS          reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    DIFFERENT       reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    OR              reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    QMARK           reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    RCOR            reduce using rule 63 (exp -> LPAREN exp RPAREN .)
    COLON           reduce using rule 63 (exp -> LPAREN exp RPAREN .)


state 160

    (85) expSeq -> exp COMMA expSeq .

    SEMICOLON       reduce using rule 85 (expSeq -> exp COMMA expSeq .)
    RPAREN          reduce using rule 85 (expSeq -> exp COMMA expSeq .)


state 161

    (37) subCall -> ID LPAREN expList RPAREN .

    SEMICOLON       reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    PLUS            reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    MINUS           reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    MULT            reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    DIVIDE          reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    MOD             reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    EQUALS          reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    DIFFERENT       reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    GT              reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    GTE             reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    LT              reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    LTE             reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    AND             reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    OR              reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    QMARK           reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    COMMA           reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    RPAREN          reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    RCOR            reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)
    COLON           reduce using rule 37 (subCall -> ID LPAREN expList RPAREN .)


state 162

    (65) var -> ID LCOR exp RCOR .

    ASSIGN          reduce using rule 65 (var -> ID LCOR exp RCOR .)
    PLUSASSIGN      reduce using rule 65 (var -> ID LCOR exp RCOR .)
    MINUSASSIGN     reduce using rule 65 (var -> ID LCOR exp RCOR .)
    MULTASSIGN      reduce using rule 65 (var -> ID LCOR exp RCOR .)
    DIVIDEASSIGN    reduce using rule 65 (var -> ID LCOR exp RCOR .)
    MODASSIGN       reduce using rule 65 (var -> ID LCOR exp RCOR .)
    SEMICOLON       reduce using rule 65 (var -> ID LCOR exp RCOR .)
    PLUS            reduce using rule 65 (var -> ID LCOR exp RCOR .)
    MINUS           reduce using rule 65 (var -> ID LCOR exp RCOR .)
    MULT            reduce using rule 65 (var -> ID LCOR exp RCOR .)
    DIVIDE          reduce using rule 65 (var -> ID LCOR exp RCOR .)
    MOD             reduce using rule 65 (var -> ID LCOR exp RCOR .)
    EQUALS          reduce using rule 65 (var -> ID LCOR exp RCOR .)
    DIFFERENT       reduce using rule 65 (var -> ID LCOR exp RCOR .)
    GT              reduce using rule 65 (var -> ID LCOR exp RCOR .)
    GTE             reduce using rule 65 (var -> ID LCOR exp RCOR .)
    LT              reduce using rule 65 (var -> ID LCOR exp RCOR .)
    LTE             reduce using rule 65 (var -> ID LCOR exp RCOR .)
    AND             reduce using rule 65 (var -> ID LCOR exp RCOR .)
    OR              reduce using rule 65 (var -> ID LCOR exp RCOR .)
    QMARK           reduce using rule 65 (var -> ID LCOR exp RCOR .)
    COMMA           reduce using rule 65 (var -> ID LCOR exp RCOR .)
    RPAREN          reduce using rule 65 (var -> ID LCOR exp RCOR .)
    RCOR            reduce using rule 65 (var -> ID LCOR exp RCOR .)
    COLON           reduce using rule 65 (var -> ID LCOR exp RCOR .)


state 163

    (81) literalSeq -> literal COMMA literalSeq .

    RKEY            reduce using rule 81 (literalSeq -> literal COMMA literalSeq .)


state 164

    (28) ifStmt -> IF LPAREN exp RPAREN LKEY . block RKEY
    (29) ifStmt -> IF LPAREN exp RPAREN LKEY . block RKEY ELSE LKEY block RKEY
    (17) block -> . varDecList stmtList
    (76) varDecList -> . varDec varDecList
    (77) varDecList -> . empty
    (7) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    block                          shift and go to state 168
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 165

    (30) whileStmt -> WHILE LPAREN exp RPAREN LKEY . block RKEY
    (17) block -> . varDecList stmtList
    (76) varDecList -> . varDec varDecList
    (77) varDecList -> . empty
    (7) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    block                          shift and go to state 169
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 166

    (31) forStmt -> FOR LPAREN assign SEMICOLON exp . SEMICOLON assign RPAREN LKEY block RKEY
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

    SEMICOLON       shift and go to state 170
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 167

    (59) exp -> exp QMARK exp COLON . exp
    (44) exp -> . exp PLUS exp
    (45) exp -> . exp MINUS exp
    (46) exp -> . exp MULT exp
    (47) exp -> . exp DIVIDE exp
    (48) exp -> . exp MOD exp
    (49) exp -> . exp EQUALS exp
    (50) exp -> . exp DIFFERENT exp
    (51) exp -> . exp GT exp
    (52) exp -> . exp GTE exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp LTE exp
    (55) exp -> . exp AND exp
    (56) exp -> . exp OR exp
    (57) exp -> . NOT exp
    (58) exp -> . UMINUS exp
    (59) exp -> . exp QMARK exp COLON exp
    (60) exp -> . subCall
    (61) exp -> . var
    (62) exp -> . literal
    (63) exp -> . LPAREN exp RPAREN
    (37) subCall -> . ID LPAREN expList RPAREN
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR
    (66) literal -> . NUMBER
    (67) literal -> . STRING_LITERAL
    (68) literal -> . FALSE
    (69) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 171
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 168

    (28) ifStmt -> IF LPAREN exp RPAREN LKEY block . RKEY
    (29) ifStmt -> IF LPAREN exp RPAREN LKEY block . RKEY ELSE LKEY block RKEY

    RKEY            shift and go to state 172


state 169

    (30) whileStmt -> WHILE LPAREN exp RPAREN LKEY block . RKEY

    RKEY            shift and go to state 173


state 170

    (31) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON . assign RPAREN LKEY block RKEY
    (38) assign -> . var ASSIGN exp
    (39) assign -> . var PLUSASSIGN exp
    (40) assign -> . var MINUSASSIGN exp
    (41) assign -> . var MULTASSIGN exp
    (42) assign -> . var DIVIDEASSIGN exp
    (43) assign -> . var MODASSIGN exp
    (64) var -> . ID
    (65) var -> . ID LCOR exp RCOR

    ID              shift and go to state 92

    assign                         shift and go to state 174
    var                            shift and go to state 70

state 171

    (59) exp -> exp QMARK exp COLON exp .
    (44) exp -> exp . PLUS exp
    (45) exp -> exp . MINUS exp
    (46) exp -> exp . MULT exp
    (47) exp -> exp . DIVIDE exp
    (48) exp -> exp . MOD exp
    (49) exp -> exp . EQUALS exp
    (50) exp -> exp . DIFFERENT exp
    (51) exp -> exp . GT exp
    (52) exp -> exp . GTE exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . LTE exp
    (55) exp -> exp . AND exp
    (56) exp -> exp . OR exp
    (59) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 59 (exp -> exp QMARK exp COLON exp .)
    COMMA           reduce using rule 59 (exp -> exp QMARK exp COLON exp .)
    RPAREN          reduce using rule 59 (exp -> exp QMARK exp COLON exp .)
    RCOR            reduce using rule 59 (exp -> exp QMARK exp COLON exp .)
    COLON           reduce using rule 59 (exp -> exp QMARK exp COLON exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! MINUS           [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! MULT            [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! DIVIDE          [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! MOD             [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! EQUALS          [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! DIFFERENT       [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! GT              [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! GTE             [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! LT              [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! LTE             [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! AND             [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! OR              [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]
  ! QMARK           [ reduce using rule 59 (exp -> exp QMARK exp COLON exp .) ]


state 172

    (28) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .
    (29) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY . ELSE LKEY block RKEY

    error           reduce using rule 28 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    IF              reduce using rule 28 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    WHILE           reduce using rule 28 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    FOR             reduce using rule 28 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    BREAK           reduce using rule 28 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    RETURN          reduce using rule 28 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    READ            reduce using rule 28 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    WRITE           reduce using rule 28 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    ID              reduce using rule 28 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    RKEY            reduce using rule 28 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    ELSE            shift and go to state 175


state 173

    (30) whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .

    error           reduce using rule 30 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    IF              reduce using rule 30 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    WHILE           reduce using rule 30 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    FOR             reduce using rule 30 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    BREAK           reduce using rule 30 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    RETURN          reduce using rule 30 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    READ            reduce using rule 30 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    WRITE           reduce using rule 30 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    ID              reduce using rule 30 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    RKEY            reduce using rule 30 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)


state 174

    (31) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 176


state 175

    (29) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE . LKEY block RKEY

    LKEY            shift and go to state 177


state 176

    (31) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN . LKEY block RKEY

    LKEY            shift and go to state 178


state 177

    (29) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY . block RKEY
    (17) block -> . varDecList stmtList
    (76) varDecList -> . varDec varDecList
    (77) varDecList -> . empty
    (7) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    block                          shift and go to state 179
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 178

    (31) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY . block RKEY
    (17) block -> . varDecList stmtList
    (76) varDecList -> . varDec varDecList
    (77) varDecList -> . empty
    (7) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (14) type -> . INT
    (15) type -> . STRING
    (16) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    block                          shift and go to state 180
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 179

    (29) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block . RKEY

    RKEY            shift and go to state 181


state 180

    (31) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block . RKEY

    RKEY            shift and go to state 182


state 181

    (29) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .

    error           reduce using rule 29 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    IF              reduce using rule 29 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    WHILE           reduce using rule 29 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    FOR             reduce using rule 29 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    BREAK           reduce using rule 29 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    RETURN          reduce using rule 29 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    READ            reduce using rule 29 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    WRITE           reduce using rule 29 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    ID              reduce using rule 29 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    RKEY            reduce using rule 29 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)


state 182

    (31) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .

    error           reduce using rule 31 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    IF              reduce using rule 31 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    WHILE           reduce using rule 31 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    FOR             reduce using rule 31 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    BREAK           reduce using rule 31 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    RETURN          reduce using rule 31 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    READ            reduce using rule 31 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    WRITE           reduce using rule 31 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    ID              reduce using rule 31 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    RKEY            reduce using rule 31 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 126 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 126 resolved as shift
WARNING: shift/reduce conflict for MULT in state 126 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 126 resolved as shift
WARNING: shift/reduce conflict for MOD in state 126 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 126 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 126 resolved as shift
WARNING: shift/reduce conflict for GT in state 126 resolved as shift
WARNING: shift/reduce conflict for GTE in state 126 resolved as shift
WARNING: shift/reduce conflict for LT in state 126 resolved as shift
WARNING: shift/reduce conflict for LTE in state 126 resolved as shift
WARNING: shift/reduce conflict for AND in state 126 resolved as shift
WARNING: shift/reduce conflict for OR in state 126 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 126 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 127 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 127 resolved as shift
WARNING: shift/reduce conflict for MULT in state 127 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 127 resolved as shift
WARNING: shift/reduce conflict for MOD in state 127 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 127 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 127 resolved as shift
WARNING: shift/reduce conflict for GT in state 127 resolved as shift
WARNING: shift/reduce conflict for GTE in state 127 resolved as shift
WARNING: shift/reduce conflict for LT in state 127 resolved as shift
WARNING: shift/reduce conflict for LTE in state 127 resolved as shift
WARNING: shift/reduce conflict for AND in state 127 resolved as shift
WARNING: shift/reduce conflict for OR in state 127 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 127 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MULT in state 145 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 145 resolved as shift
WARNING: shift/reduce conflict for MOD in state 145 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 145 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 145 resolved as shift
WARNING: shift/reduce conflict for GT in state 145 resolved as shift
WARNING: shift/reduce conflict for GTE in state 145 resolved as shift
WARNING: shift/reduce conflict for LT in state 145 resolved as shift
WARNING: shift/reduce conflict for LTE in state 145 resolved as shift
WARNING: shift/reduce conflict for AND in state 145 resolved as shift
WARNING: shift/reduce conflict for OR in state 145 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 145 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MULT in state 146 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 146 resolved as shift
WARNING: shift/reduce conflict for MOD in state 146 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 146 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 146 resolved as shift
WARNING: shift/reduce conflict for GT in state 146 resolved as shift
WARNING: shift/reduce conflict for GTE in state 146 resolved as shift
WARNING: shift/reduce conflict for LT in state 146 resolved as shift
WARNING: shift/reduce conflict for LTE in state 146 resolved as shift
WARNING: shift/reduce conflict for AND in state 146 resolved as shift
WARNING: shift/reduce conflict for OR in state 146 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 146 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MULT in state 147 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 147 resolved as shift
WARNING: shift/reduce conflict for MOD in state 147 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 147 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 147 resolved as shift
WARNING: shift/reduce conflict for GT in state 147 resolved as shift
WARNING: shift/reduce conflict for GTE in state 147 resolved as shift
WARNING: shift/reduce conflict for LT in state 147 resolved as shift
WARNING: shift/reduce conflict for LTE in state 147 resolved as shift
WARNING: shift/reduce conflict for AND in state 147 resolved as shift
WARNING: shift/reduce conflict for OR in state 147 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 147 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MULT in state 148 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 148 resolved as shift
WARNING: shift/reduce conflict for MOD in state 148 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 148 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 148 resolved as shift
WARNING: shift/reduce conflict for GT in state 148 resolved as shift
WARNING: shift/reduce conflict for GTE in state 148 resolved as shift
WARNING: shift/reduce conflict for LT in state 148 resolved as shift
WARNING: shift/reduce conflict for LTE in state 148 resolved as shift
WARNING: shift/reduce conflict for AND in state 148 resolved as shift
WARNING: shift/reduce conflict for OR in state 148 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 148 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MULT in state 149 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 149 resolved as shift
WARNING: shift/reduce conflict for MOD in state 149 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 149 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 149 resolved as shift
WARNING: shift/reduce conflict for GT in state 149 resolved as shift
WARNING: shift/reduce conflict for GTE in state 149 resolved as shift
WARNING: shift/reduce conflict for LT in state 149 resolved as shift
WARNING: shift/reduce conflict for LTE in state 149 resolved as shift
WARNING: shift/reduce conflict for AND in state 149 resolved as shift
WARNING: shift/reduce conflict for OR in state 149 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 149 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MULT in state 150 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 150 resolved as shift
WARNING: shift/reduce conflict for MOD in state 150 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 150 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 150 resolved as shift
WARNING: shift/reduce conflict for GT in state 150 resolved as shift
WARNING: shift/reduce conflict for GTE in state 150 resolved as shift
WARNING: shift/reduce conflict for LT in state 150 resolved as shift
WARNING: shift/reduce conflict for LTE in state 150 resolved as shift
WARNING: shift/reduce conflict for AND in state 150 resolved as shift
WARNING: shift/reduce conflict for OR in state 150 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 150 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MULT in state 151 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 151 resolved as shift
WARNING: shift/reduce conflict for MOD in state 151 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 151 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 151 resolved as shift
WARNING: shift/reduce conflict for GT in state 151 resolved as shift
WARNING: shift/reduce conflict for GTE in state 151 resolved as shift
WARNING: shift/reduce conflict for LT in state 151 resolved as shift
WARNING: shift/reduce conflict for LTE in state 151 resolved as shift
WARNING: shift/reduce conflict for AND in state 151 resolved as shift
WARNING: shift/reduce conflict for OR in state 151 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 151 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MULT in state 152 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 152 resolved as shift
WARNING: shift/reduce conflict for MOD in state 152 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 152 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 152 resolved as shift
WARNING: shift/reduce conflict for GT in state 152 resolved as shift
WARNING: shift/reduce conflict for GTE in state 152 resolved as shift
WARNING: shift/reduce conflict for LT in state 152 resolved as shift
WARNING: shift/reduce conflict for LTE in state 152 resolved as shift
WARNING: shift/reduce conflict for AND in state 152 resolved as shift
WARNING: shift/reduce conflict for OR in state 152 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 152 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MULT in state 153 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 153 resolved as shift
WARNING: shift/reduce conflict for MOD in state 153 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 153 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 153 resolved as shift
WARNING: shift/reduce conflict for GT in state 153 resolved as shift
WARNING: shift/reduce conflict for GTE in state 153 resolved as shift
WARNING: shift/reduce conflict for LT in state 153 resolved as shift
WARNING: shift/reduce conflict for LTE in state 153 resolved as shift
WARNING: shift/reduce conflict for AND in state 153 resolved as shift
WARNING: shift/reduce conflict for OR in state 153 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 153 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 154 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 154 resolved as shift
WARNING: shift/reduce conflict for MULT in state 154 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 154 resolved as shift
WARNING: shift/reduce conflict for MOD in state 154 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 154 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 154 resolved as shift
WARNING: shift/reduce conflict for GT in state 154 resolved as shift
WARNING: shift/reduce conflict for GTE in state 154 resolved as shift
WARNING: shift/reduce conflict for LT in state 154 resolved as shift
WARNING: shift/reduce conflict for LTE in state 154 resolved as shift
WARNING: shift/reduce conflict for AND in state 154 resolved as shift
WARNING: shift/reduce conflict for OR in state 154 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 154 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 155 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 155 resolved as shift
WARNING: shift/reduce conflict for MULT in state 155 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 155 resolved as shift
WARNING: shift/reduce conflict for MOD in state 155 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 155 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 155 resolved as shift
WARNING: shift/reduce conflict for GT in state 155 resolved as shift
WARNING: shift/reduce conflict for GTE in state 155 resolved as shift
WARNING: shift/reduce conflict for LT in state 155 resolved as shift
WARNING: shift/reduce conflict for LTE in state 155 resolved as shift
WARNING: shift/reduce conflict for AND in state 155 resolved as shift
WARNING: shift/reduce conflict for OR in state 155 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 155 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MULT in state 156 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 156 resolved as shift
WARNING: shift/reduce conflict for MOD in state 156 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 156 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 156 resolved as shift
WARNING: shift/reduce conflict for GT in state 156 resolved as shift
WARNING: shift/reduce conflict for GTE in state 156 resolved as shift
WARNING: shift/reduce conflict for LT in state 156 resolved as shift
WARNING: shift/reduce conflict for LTE in state 156 resolved as shift
WARNING: shift/reduce conflict for AND in state 156 resolved as shift
WARNING: shift/reduce conflict for OR in state 156 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 156 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 157 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 157 resolved as shift
WARNING: shift/reduce conflict for MULT in state 157 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 157 resolved as shift
WARNING: shift/reduce conflict for MOD in state 157 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 157 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 157 resolved as shift
WARNING: shift/reduce conflict for GT in state 157 resolved as shift
WARNING: shift/reduce conflict for GTE in state 157 resolved as shift
WARNING: shift/reduce conflict for LT in state 157 resolved as shift
WARNING: shift/reduce conflict for LTE in state 157 resolved as shift
WARNING: shift/reduce conflict for AND in state 157 resolved as shift
WARNING: shift/reduce conflict for OR in state 157 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 157 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 171 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 171 resolved as shift
WARNING: shift/reduce conflict for MULT in state 171 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 171 resolved as shift
WARNING: shift/reduce conflict for MOD in state 171 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 171 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 171 resolved as shift
WARNING: shift/reduce conflict for GT in state 171 resolved as shift
WARNING: shift/reduce conflict for GTE in state 171 resolved as shift
WARNING: shift/reduce conflict for LT in state 171 resolved as shift
WARNING: shift/reduce conflict for LTE in state 171 resolved as shift
WARNING: shift/reduce conflict for AND in state 171 resolved as shift
WARNING: shift/reduce conflict for OR in state 171 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 171 resolved as shift
